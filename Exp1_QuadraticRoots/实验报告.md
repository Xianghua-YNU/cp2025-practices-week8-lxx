# 实验1: 二次方程求根的稳定性

## 1. 实验目的
1. 探究二次方程求根过程中可能出现的数值不稳定问题
2. 分析不同求根公式在不同参数条件下的误差表现
3. 理解数值计算中精度损失的原因及改进方法

## 2. 实验方法
1. 使用公式法求解二次方程 $ax^2+bx+c=0$ 的根
2. 实现两种不同的求根公式：
   - 标准求根公式： $x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$
   - 替换求根公式： $x = {2c\over-b\mp\sqrt{b^2-4ac}}$
3. 比较两种方法在不同参数条件下的数值稳定性，找到一种稳定的求根方法。

## 3. 实验结果
展示计算得到的主要数据、图表和观察现象。
### 测试方程1: 1x^2 + 2x + 1 = 0
方法1（标准公式）的结果：
x1 = -1.000000000000000, x2 = -1.000000000000000

方法2（替代公式）的结果：
x1 = -1.000000000000000, x2 = -1.000000000000000

方法3（稳定求根程序）的结果：
x1 = -1.000000000000000, x2 = -1.000000000000000
### 测试方程2: 1x^2 + 100000x + 1 = 0
方法1（标准公式）的结果：
x1 = -0.000010000000000, x2 = -99999.999990000000000

方法2（替代公式）的结果：
x1 = -0.000010000000100, x2 = -99999.999990000000000

方法3（稳定求根程序）的结果：
x1 = -0.000010000000100, x2 = -99999.999990000000000
### 测试方程3: 0.001x^2 + 1000x + 0.001 = 0
方法1（标准公式）的结果：
x1 = -0.000000001000000, x2 = -999999.999999000000000

方法2（替代公式）的结果：
x1 = -0.000000001000000, x2 = -1000000000.000000000000000

方法3（稳定求根程序）的结果：
x1 = -0.000000001000000, x2 = -999999.999999000000000

## 4. 分析与讨论
### 1. 分析两种方法在不同参数条件下的误差表现
   对于简单方程(测试1)，三种方法结果一致且准确

   当b远大于a和c时(测试2)，标准公式和替代公式在小根计算上出现微小差异

   极端情况下(测试3)，标准公式和替代公式分别在不同根上出现精度问题
   
### 2. 讨论数值计算中可能出现的问题及改进方法
   - 数值不稳定性原因：

   当b²远大于4ac时，√(b²-4ac)≈|b|，导致两个相近数相减，造成"灾难性抵消"

   标准公式在计算小根(-b+√Δ)/2a时精度损失严重

   替代公式在计算大根2c/(-b-√Δ)时可能溢出或精度不足

   - 改进方法：

   根据根的大小选择适当的计算公式：

   对于大绝对值的根，使用标准公式

   对于小绝对值的根，使用替代公式

   综合两种方法的优点，构建稳定的求根算法

## 附录：核心代码片段
```python
def standard_formula(a, b, c):
    """使用标准公式求解二次方程"""
    discriminant = b**2 - 4*a*c
    if discriminant < 0:
        return None
    sqrt_disc = np.sqrt(discriminant)
    x1 = (-b + sqrt_disc) / (2*a)
    x2 = (-b - sqrt_disc) / (2*a)
    return (x1, x2)

def alternative_formula(a, b, c):
    """使用替代公式求解二次方程"""
    discriminant = b**2 - 4*a*c
    if discriminant < 0:
        return None
    sqrt_disc = np.sqrt(discriminant)
    x1 = (2*c) / (-b + sqrt_disc)
    x2 = (2*c) / (-b - sqrt_disc)
    return (x1, x2)

def stable_formula(a, b, c):
    """稳定的二次方程求根程序"""
    discriminant = b**2 - 4*a*c
    if discriminant < 0:
        return None
    
    sqrt_disc = np.sqrt(discriminant)
    
    # 根据b的符号选择计算方式以避免抵消
    if b > 0:
        x1 = (2*c) / (-b - sqrt_disc)
        x2 = (-b - sqrt_disc) / (2*a)
    else:
        x1 = (-b + sqrt_disc) / (2*a)
        x2 = (2*c) / (-b + sqrt_disc)
    
    return (x1, x2)
```
